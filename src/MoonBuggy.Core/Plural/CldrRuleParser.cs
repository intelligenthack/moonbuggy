// <auto-generated/>
#nullable enable

using System;
using System.Collections.Generic;

namespace MoonBuggy.Core.Plural
{
    /// <summary>
    /// Parses CLDR plural rule condition strings into an AST.
    /// Input is the condition part only (before @integer/@decimal samples).
    /// </summary>
    internal static class CldrRuleParser
    {
        public static OrExpr? Parse(string condition)
        {
            condition = StripSamples(condition).Trim();
            if (string.IsNullOrWhiteSpace(condition))
                return null; // unconditional ("other")

            var tokens = Tokenize(condition);
            int pos = 0;
            return ParseOrExpr(tokens, ref pos);
        }

        private static string StripSamples(string s)
        {
            int idx = s.IndexOf('@');
            return idx >= 0 ? s.Substring(0, idx) : s;
        }

        private static List<string> Tokenize(string s)
        {
            var tokens = new List<string>();
            int i = 0;
            while (i < s.Length)
            {
                if (char.IsWhiteSpace(s[i])) { i++; continue; }

                if (s[i] == '!' && i + 1 < s.Length && s[i + 1] == '=')
                {
                    tokens.Add("!=");
                    i += 2;
                    continue;
                }

                if (s[i] == '.' && i + 1 < s.Length && s[i + 1] == '.')
                {
                    tokens.Add("..");
                    i += 2;
                    continue;
                }

                if (s[i] == '=' || s[i] == '%' || s[i] == ',')
                {
                    tokens.Add(s[i].ToString());
                    i++;
                    continue;
                }

                // number or identifier
                int start = i;
                while (i < s.Length && (char.IsLetterOrDigit(s[i]) || s[i] == '_'))
                    i++;

                if (i > start)
                    tokens.Add(s.Substring(start, i - start));
            }
            return tokens;
        }

        private static OrExpr ParseOrExpr(List<string> tokens, ref int pos)
        {
            var branches = new List<AndExpr>();
            branches.Add(ParseAndExpr(tokens, ref pos));

            while (pos < tokens.Count && tokens[pos] == "or")
            {
                pos++; // skip "or"
                branches.Add(ParseAndExpr(tokens, ref pos));
            }

            return new OrExpr(branches);
        }

        private static AndExpr ParseAndExpr(List<string> tokens, ref int pos)
        {
            var relations = new List<Relation>();
            relations.Add(ParseRelation(tokens, ref pos));

            while (pos < tokens.Count && tokens[pos] == "and")
            {
                pos++; // skip "and"
                relations.Add(ParseRelation(tokens, ref pos));
            }

            return new AndExpr(relations);
        }

        private static Relation ParseRelation(List<string> tokens, ref int pos)
        {
            string operand = tokens[pos++]; // n, i, v, w, f, t, e

            int? modulus = null;
            if (pos < tokens.Count && tokens[pos] == "%")
            {
                pos++; // skip %
                modulus = int.Parse(tokens[pos++]);
            }

            bool negated = false;
            if (pos < tokens.Count)
            {
                if (tokens[pos] == "!=")
                {
                    negated = true;
                    pos++;
                }
                else if (tokens[pos] == "=")
                {
                    pos++;
                }
            }

            var ranges = ParseRangeList(tokens, ref pos);
            return new Relation(operand, modulus, negated, ranges);
        }

        private static List<RangeValue> ParseRangeList(List<string> tokens, ref int pos)
        {
            var ranges = new List<RangeValue>();
            ranges.Add(ParseRange(tokens, ref pos));

            while (pos < tokens.Count && tokens[pos] == ",")
            {
                pos++; // skip comma
                ranges.Add(ParseRange(tokens, ref pos));
            }

            return ranges;
        }

        private static RangeValue ParseRange(List<string> tokens, ref int pos)
        {
            long low = long.Parse(tokens[pos++]);

            if (pos < tokens.Count && tokens[pos] == "..")
            {
                pos++; // skip ..
                long high = long.Parse(tokens[pos++]);
                return new RangeValue(low, high);
            }

            return new RangeValue(low);
        }
    }
}
