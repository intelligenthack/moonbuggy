// <auto-generated/>
#nullable enable

using System.Collections.Generic;
using System.Linq;

namespace MoonBuggy.Core.Plural
{
    /// <summary>
    /// Simplifies CLDR plural rule ASTs for integer-only types.
    /// For integers: v=0, w=0, f=0, t=0, e=0, and i=n.
    /// </summary>
    internal static class IntegerSimplifier
    {
        /// <summary>
        /// Returns null if the entire rule is dead (always false).
        /// Returns an empty OrExpr (no branches) if it shouldn't happen.
        /// </summary>
        public static OrExpr? Simplify(OrExpr? expr)
        {
            if (expr == null) return null; // unconditional remains unconditional

            var liveBranches = new List<AndExpr>();

            foreach (var branch in expr.Branches)
            {
                var simplified = SimplifyAnd(branch);
                if (simplified != null)
                    liveBranches.Add(simplified);
            }

            if (liveBranches.Count == 0)
                return null; // all branches dead → entire rule is dead

            return new OrExpr(liveBranches);
        }

        private static AndExpr? SimplifyAnd(AndExpr and)
        {
            var liveRelations = new List<Relation>();

            foreach (var rel in and.Relations)
            {
                var result = SimplifyRelation(rel);
                if (result.IsAlwaysTrue)
                    continue;       // drop from AND chain
                if (result.IsAlwaysFalse)
                    return null;    // kill entire AND chain
                liveRelations.Add(result.Relation!);
            }

            if (liveRelations.Count == 0)
            {
                // All relations were always-true → this branch is unconditional
                // Return an empty AndExpr to signal "always true"
                return new AndExpr(liveRelations);
            }

            return new AndExpr(liveRelations);
        }

        private static SimplifyResult SimplifyRelation(Relation rel)
        {
            // For integers: v=0, w=0, f=0, t=0, e=0
            if (IsZeroOperand(rel.Operand))
            {
                return SimplifyZeroOperand(rel);
            }

            // Replace i with n
            string operand = rel.Operand == "i" ? "n" : rel.Operand;

            return new SimplifyResult(new Relation(operand, rel.Modulus, rel.Negated, rel.Ranges));
        }

        private static bool IsZeroOperand(string op)
        {
            return op == "v" || op == "w" || op == "f" || op == "t" || op == "e";
        }

        private static SimplifyResult SimplifyZeroOperand(Relation rel)
        {
            // The operand is always 0 for integers.
            // Check if 0 satisfies the relation.
            bool zeroMatches = RangesContain(rel.Ranges, 0);

            if (rel.Negated)
            {
                // operand != ranges: true when 0 is NOT in ranges
                return zeroMatches ? SimplifyResult.AlwaysFalse : SimplifyResult.AlwaysTrue;
            }
            else
            {
                // operand = ranges: true when 0 IS in ranges
                return zeroMatches ? SimplifyResult.AlwaysTrue : SimplifyResult.AlwaysFalse;
            }
        }

        private static bool RangesContain(List<RangeValue> ranges, long value)
        {
            return ranges.Any(r => r.Contains(value));
        }

        private struct SimplifyResult
        {
            public static readonly SimplifyResult AlwaysTrue = new SimplifyResult(true);
            public static readonly SimplifyResult AlwaysFalse = new SimplifyResult(false);

            public Relation? Relation { get; }
            private readonly bool _isTrue;

            public SimplifyResult(Relation relation)
            {
                Relation = relation;
                _isTrue = false;
            }

            private SimplifyResult(bool isTrue)
            {
                Relation = null;
                _isTrue = isTrue;
            }

            public bool IsAlwaysTrue => Relation == null && _isTrue;
            public bool IsAlwaysFalse => Relation == null && !_isTrue;
        }
    }
}
