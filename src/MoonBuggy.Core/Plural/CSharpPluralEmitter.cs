// <auto-generated/>
#nullable enable

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace MoonBuggy.Core.Plural
{
    /// <summary>
    /// Emits C# code from simplified CLDR plural rule ASTs.
    /// </summary>
    internal static class CSharpPluralEmitter
    {
        /// <summary>
        /// Emits the condition expression for a single rule as a C# boolean expression string.
        /// Returns null for unconditional rules (the "other" category).
        /// </summary>
        public static string? EmitCondition(OrExpr? simplified)
        {
            if (simplified == null) return null;

            var sb = new StringBuilder();
            for (int i = 0; i < simplified.Branches.Count; i++)
            {
                if (i > 0) sb.Append(" || ");

                var branch = simplified.Branches[i];
                if (branch.Relations.Count == 0)
                {
                    // Unconditional branch — entire OR is true
                    return null;
                }

                bool needParens = simplified.Branches.Count > 1 && branch.Relations.Count > 1;
                if (needParens) sb.Append('(');

                for (int j = 0; j < branch.Relations.Count; j++)
                {
                    if (j > 0) sb.Append(" && ");
                    EmitRelation(sb, branch.Relations[j]);
                }

                if (needParens) sb.Append(')');
            }

            return sb.ToString();
        }

        private static void EmitRelation(StringBuilder sb, Relation rel)
        {
            string expr = rel.Modulus.HasValue
                ? $"n % {rel.Modulus.Value}"
                : "n";

            if (rel.Ranges.Count == 1 && rel.Ranges[0].IsSingle)
            {
                // Simple equality: n == 1 or n != 1
                sb.Append($"{expr} {(rel.Negated ? "!=" : "==")} {rel.Ranges[0].Low}");
            }
            else if (rel.Ranges.Count == 1 && !rel.Ranges[0].IsSingle)
            {
                // Single range: n >= 3 && n <= 10
                EmitSingleRange(sb, expr, rel.Ranges[0], rel.Negated);
            }
            else
            {
                // Multiple values/ranges — complex expression
                EmitMultiRangeCheck(sb, expr, rel.Ranges, rel.Negated);
            }
        }

        private static void EmitSingleRange(StringBuilder sb, string expr, RangeValue range, bool negated)
        {
            if (negated)
            {
                sb.Append($"({expr} < {range.Low} || {expr} > {range.High})");
            }
            else
            {
                sb.Append($"{expr} >= {range.Low} && {expr} <= {range.High}");
            }
        }

        private static void EmitMultiRangeCheck(StringBuilder sb, string expr, List<RangeValue> ranges, bool negated)
        {
            // For = with multiple values: (n == 1 || n == 2) or for ranges: (n >= 3 && n <= 4 || n == 9)
            // For != with multiple values: (n != 1 && n != 2) or negate with ranges
            if (negated)
            {
                // != means none of the ranges match
                bool needOuterParens = ranges.Count > 1;
                if (needOuterParens) sb.Append('(');
                for (int i = 0; i < ranges.Count; i++)
                {
                    if (i > 0) sb.Append(" && ");
                    if (ranges[i].IsSingle)
                    {
                        sb.Append($"{expr} != {ranges[i].Low}");
                    }
                    else
                    {
                        sb.Append($"({expr} < {ranges[i].Low} || {expr} > {ranges[i].High})");
                    }
                }
                if (needOuterParens) sb.Append(')');
            }
            else
            {
                // = means any of the ranges match
                bool needOuterParens = ranges.Count > 1;
                if (needOuterParens) sb.Append('(');
                for (int i = 0; i < ranges.Count; i++)
                {
                    if (i > 0) sb.Append(" || ");
                    if (ranges[i].IsSingle)
                    {
                        sb.Append($"{expr} == {ranges[i].Low}");
                    }
                    else
                    {
                        sb.Append($"({expr} >= {ranges[i].Low} && {expr} <= {ranges[i].High})");
                    }
                }
                if (needOuterParens) sb.Append(')');
            }
        }

        /// <summary>
        /// Emits a complete GetCategory method body for a set of locale rules.
        /// </summary>
        public static string EmitCategoryBody(
            Dictionary<PluralCategory, OrExpr?> rules,
            string indent = "                    ")
        {
            var sb = new StringBuilder();

            // Categories in CLDR order, except "other" which is always the fallback
            var orderedCategories = new[] {
                PluralCategory.Zero, PluralCategory.One, PluralCategory.Two,
                PluralCategory.Few, PluralCategory.Many
            };

            foreach (var cat in orderedCategories)
            {
                if (!rules.ContainsKey(cat)) continue;

                var condition = EmitCondition(rules[cat]);
                if (condition == null)
                {
                    // Unconditional (shouldn't happen for non-other, but handle gracefully)
                    sb.AppendLine($"{indent}return PluralCategory.{cat};");
                }
                else
                {
                    sb.AppendLine($"{indent}if ({condition}) return PluralCategory.{cat};");
                }
            }

            sb.Append($"{indent}return PluralCategory.Other;");
            return sb.ToString();
        }
    }
}
