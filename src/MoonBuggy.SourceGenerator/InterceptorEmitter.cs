using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using MoonBuggy.Core.Icu;
using MoonBuggy.Core.Markdown;
using MoonBuggy.Core.Parsing;
using MoonBuggy.Core.Po;
using MoonBuggy.Core.Plural;

namespace MoonBuggy.SourceGenerator;

internal sealed class LocaleTranslation
{
    public string Locale { get; set; } = "";
    public int Lcid { get; set; }
    public PoCatalog Catalog { get; set; } = new PoCatalog();
}

internal static class InterceptorEmitter
{
    public static string Emit(List<CallSiteInfo> callSites, List<LocaleTranslation> translations)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("#pragma warning disable RSEXPERIMENTAL002");
        sb.AppendLine();
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("using Microsoft.AspNetCore.Html;");
        sb.AppendLine();
        sb.AppendLine("namespace MoonBuggy.Generated");
        sb.AppendLine("{");
        sb.AppendLine("    internal static class Interceptors");
        sb.AppendLine("    {");

        for (int i = 0; i < callSites.Count; i++)
        {
            var site = callSites[i];
            EmitInterceptor(sb, site, i, translations);
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void EmitInterceptor(
        StringBuilder sb, CallSiteInfo site, int index, List<LocaleTranslation> translations)
    {
        var prefix = site.IsMarkdown ? "__m" : "__t";
        var returnType = site.IsMarkdown ? "IHtmlContent" : "string";

        sb.AppendLine($"        [InterceptsLocation({site.InterceptableLocationVersion}, \"{EscapeString(site.InterceptableLocationData)}\")]");
        sb.AppendLine($"        internal static {returnType} {prefix}_{index}(string message, object? args = null, string? context = null)");
        sb.AppendLine("        {");

        // For _m(), derive ICU msgid via markdown extraction + get placeholder mappings
        string icuMsgId;
        List<PlaceholderMapping>? mappings = null;

        if (site.IsMarkdown)
        {
            icuMsgId = MarkdownPlaceholderExtractor.ToIcuWithMarkdown(site.Message);
            // Also extract the mappings for resolving <N> in translated text
            var tokens = MbParser.Parse(site.Message);
            mappings = ExtractAllMappings(tokens);
        }
        else
        {
            var tokens = MbParser.Parse(site.Message);
            icuMsgId = IcuTransformer.Transform(tokens);
        }

        // For source locale, resolve placeholders to actual HTML, then parse ICU
        var sourceIcu = site.IsMarkdown ? ResolvePlaceholders(icuMsgId, mappings!) : icuMsgId;
        var sourceNodes = IcuParser.Parse(sourceIcu);

        // Extract args from dynamic
        if (site.ArgProperties.Count > 0)
        {
            sb.AppendLine("            var __args = (dynamic)args!;");
        }

        // Extract integer variables used as plural selectors
        var pluralVars = CollectPluralVariables(sourceNodes);
        foreach (var pv in pluralVars)
        {
            sb.AppendLine($"            int __{pv} = (int)__args.{pv};");
        }

        // Collect locale branches
        var localeBranches = new List<(int Lcid, string Locale, IcuNode[] Nodes)>();
        foreach (var translation in translations)
        {
            var entry = translation.Catalog.Find(icuMsgId, site.Context);
            if (entry != null && !string.IsNullOrEmpty(entry.MsgStr))
            {
                var translatedIcu = site.IsMarkdown
                    ? ResolvePlaceholders(entry.MsgStr, mappings!)
                    : entry.MsgStr;
                var translatedNodes = IcuParser.Parse(translatedIcu);
                localeBranches.Add((translation.Lcid, translation.Locale, translatedNodes));
            }
        }

        if (localeBranches.Count > 0)
        {
            sb.AppendLine("            var lcid = MoonBuggy.I18n.Current.LCID;");

            foreach (var (lcid, locale, nodes) in localeBranches)
            {
                sb.AppendLine($"            if (lcid == {lcid})");
                sb.AppendLine("            {");
                EmitNodeReturn(sb, site, nodes, locale, "                ");
                sb.AppendLine("            }");
            }
        }

        // Source locale fallback
        EmitNodeReturn(sb, site, sourceNodes, "en", "            ");

        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static List<PlaceholderMapping> ExtractAllMappings(MbToken[] tokens)
    {
        // Walk tokens to extract markdown and collect all mappings
        var sb = new StringBuilder();
        var index = 0;
        var allMappings = new List<PlaceholderMapping>();

        foreach (var token in tokens)
        {
            switch (token)
            {
                case TextToken t:
                    sb.Append(t.Value);
                    break;
                case VariableToken v:
                    sb.Append('{');
                    sb.Append(v.Name);
                    sb.Append('}');
                    break;
                case PluralBlockToken p:
                    // Flush text through markdown
                    FlushAndCollect(sb, ref index, allMappings);
                    // Process each form's content
                    foreach (var form in p.Forms)
                    {
                        var formSb = new StringBuilder();
                        foreach (var ft in form.Content)
                        {
                            switch (ft)
                            {
                                case TextToken t: formSb.Append(t.Value); break;
                                case VariableToken v: formSb.Append('{').Append(v.Name).Append('}'); break;
                                case PluralSelectorRef: formSb.Append('\uFFF2'); break;
                            }
                        }
                        var result = MarkdownPlaceholderExtractor.Extract(formSb.ToString(), index);
                        allMappings.AddRange(result.Mappings);
                        index = result.NextIndex;
                    }
                    break;
            }
        }

        FlushAndCollect(sb, ref index, allMappings);
        return allMappings;
    }

    private static void FlushAndCollect(StringBuilder sb, ref int index, List<PlaceholderMapping> allMappings)
    {
        if (sb.Length == 0) return;
        var result = MarkdownPlaceholderExtractor.Extract(sb.ToString(), index);
        allMappings.AddRange(result.Mappings);
        index = result.NextIndex;
        sb.Clear();
    }

    internal static string ResolvePlaceholders(string icu, List<PlaceholderMapping> mappings)
    {
        // Replace <N> with OpenTag and </N> with CloseTag
        var result = icu;
        foreach (var mapping in mappings)
        {
            result = result.Replace($"<{mapping.Index}>", mapping.OpenTag);
            result = result.Replace($"</{mapping.Index}>", mapping.CloseTag);
        }
        return result;
    }

    private static HashSet<string> CollectPluralVariables(IcuNode[] nodes)
    {
        var vars = new HashSet<string>();
        foreach (var node in nodes)
        {
            if (node is IcuPluralNode plural)
            {
                vars.Add(plural.Variable);
                foreach (var branch in plural.Branches)
                    foreach (var v in CollectPluralVariables(branch.Content))
                        vars.Add(v);
            }
        }
        return vars;
    }

    private static void EmitNodeReturn(
        StringBuilder sb, CallSiteInfo site, IcuNode[] nodes, string locale, string indent)
    {
        if (!ContainsPluralNode(nodes))
        {
            EmitSimpleReturn(sb, site, nodes, indent, null);
            return;
        }

        EmitNodesWithPlurals(sb, site, nodes, locale, indent);
    }

    private static bool ContainsPluralNode(IcuNode[] nodes)
    {
        foreach (var node in nodes)
        {
            if (node is IcuPluralNode) return true;
        }
        return false;
    }

    private static void EmitNodesWithPlurals(
        StringBuilder sb, CallSiteInfo site, IcuNode[] nodes, string locale, string indent)
    {
        var plurals = new List<(int Index, IcuPluralNode Plural)>();
        for (int i = 0; i < nodes.Length; i++)
        {
            if (nodes[i] is IcuPluralNode p)
                plurals.Add((i, p));
        }

        if (plurals.Count == 1)
        {
            EmitSinglePluralReturn(sb, site, nodes, plurals[0].Index, plurals[0].Plural, locale, indent);
        }
        else
        {
            EmitMultiPluralReturn(sb, site, nodes, plurals, locale, indent);
        }
    }

    private static void EmitSinglePluralReturn(
        StringBuilder sb, CallSiteInfo site, IcuNode[] nodes, int pluralIndex,
        IcuPluralNode plural, string locale, string indent)
    {
        var prefixNodes = nodes.Take(pluralIndex).ToArray();
        var suffixNodes = nodes.Skip(pluralIndex + 1).ToArray();
        var varName = $"__{plural.Variable}";

        foreach (var branch in plural.Branches)
        {
            var condition = GetCategoryCondition(branch.Category, varName, locale);
            if (condition != null)
            {
                sb.AppendLine($"{indent}if ({condition})");
                var branchNodes = CombineNodes(prefixNodes, branch.Content, suffixNodes);
                EmitSimpleReturn(sb, site, branchNodes, indent + "    ", plural.Variable);
            }
        }

        var otherBranch = plural.Branches.FirstOrDefault(b => b.Category == "other")
                          ?? plural.Branches.Last();
        var fallbackNodes = CombineNodes(prefixNodes, otherBranch.Content, suffixNodes);
        EmitSimpleReturn(sb, site, fallbackNodes, indent, plural.Variable);
    }

    private static void EmitMultiPluralReturn(
        StringBuilder sb, CallSiteInfo site, IcuNode[] nodes,
        List<(int Index, IcuPluralNode Plural)> plurals, string locale, string indent)
    {
        var first = plurals[0];
        var prefixNodes = nodes.Take(first.Index).ToArray();
        var suffixNodes = nodes.Skip(first.Index + 1).ToArray();
        var varName = $"__{first.Plural.Variable}";

        foreach (var branch in first.Plural.Branches)
        {
            var condition = GetCategoryCondition(branch.Category, varName, locale);
            if (condition != null)
            {
                sb.AppendLine($"{indent}if ({condition})");
                sb.AppendLine($"{indent}{{");
                var expanded = CombineNodes(prefixNodes, branch.Content, suffixNodes);
                EmitNodeReturn(sb, site, expanded, locale, indent + "    ");
                sb.AppendLine($"{indent}}}");
            }
        }

        var otherBranch = first.Plural.Branches.FirstOrDefault(b => b.Category == "other")
                          ?? first.Plural.Branches.Last();
        var fallbackExpanded = CombineNodes(prefixNodes, otherBranch.Content, suffixNodes);
        EmitNodeReturn(sb, site, fallbackExpanded, locale, indent);
    }

    private static IcuNode[] CombineNodes(IcuNode[] prefix, IcuNode[] middle, IcuNode[] suffix)
    {
        var result = new List<IcuNode>();
        result.AddRange(prefix);
        result.AddRange(middle);
        result.AddRange(suffix);
        return result.ToArray();
    }

    private static string? GetCategoryCondition(
        string icuCategory, string varName, string locale)
    {
        if (icuCategory.StartsWith("="))
        {
            return $"{varName} == {icuCategory.Substring(1)}";
        }

        PluralCategory cat;
        switch (icuCategory)
        {
            case "zero": cat = PluralCategory.Zero; break;
            case "one": cat = PluralCategory.One; break;
            case "two": cat = PluralCategory.Two; break;
            case "few": cat = PluralCategory.Few; break;
            case "many": cat = PluralCategory.Many; break;
            case "other": return null;
            default: return null;
        }

        var lang = locale.Contains("-") ? locale.Split('-')[0] : locale;
        var condition = CldrPluralRuleConditions.GetCondition(lang, cat);
        if (condition == null)
            return null;

        return condition.Replace("n", varName);
    }

    private static void EmitSimpleReturn(
        StringBuilder sb, CallSiteInfo site, IcuNode[] nodes, string indent, string? pluralVariable)
    {
        var parts = FlattenNodes(nodes, site, pluralVariable);

        if (site.IsMarkdown)
        {
            EmitHtmlReturn(sb, parts, indent);
        }
        else
        {
            EmitStringReturn(sb, parts, indent);
        }
    }

    private static void EmitStringReturn(StringBuilder sb, List<string> parts, string indent)
    {
        if (parts.Count == 0)
        {
            sb.AppendLine($"{indent}return \"\";");
            return;
        }
        if (parts.Count == 1)
        {
            sb.AppendLine($"{indent}return {parts[0]};");
            return;
        }
        sb.Append($"{indent}return string.Concat(");
        for (int i = 0; i < parts.Count; i++)
        {
            if (i > 0) sb.Append(", ");
            sb.Append(parts[i]);
        }
        sb.AppendLine(");");
    }

    private static void EmitHtmlReturn(StringBuilder sb, List<string> parts, string indent)
    {
        if (parts.Count == 0)
        {
            sb.AppendLine($"{indent}return new HtmlString(\"\");");
            return;
        }
        if (parts.Count == 1)
        {
            sb.AppendLine($"{indent}return new HtmlString({parts[0]});");
            return;
        }
        sb.Append($"{indent}return new HtmlString(string.Concat(");
        for (int i = 0; i < parts.Count; i++)
        {
            if (i > 0) sb.Append(", ");
            sb.Append(parts[i]);
        }
        sb.AppendLine("));");
    }

    internal static List<string> FlattenNodes(IcuNode[] nodes, CallSiteInfo site, string? pluralVariable)
    {
        var parts = new List<string>();
        foreach (var node in nodes)
        {
            switch (node)
            {
                case IcuTextNode text:
                    parts.Add($"\"{EscapeString(text.Value)}\"");
                    break;

                case IcuVariableNode variable:
                    var argType = site.ArgProperties
                        .FirstOrDefault(a => a.Name == variable.Name).TypeName;
                    if (argType == "string")
                        parts.Add($"(string)__args.{variable.Name}");
                    else
                        parts.Add($"((object)__args.{variable.Name}).ToString()");
                    break;

                case IcuHashNode:
                    if (pluralVariable != null)
                        parts.Add($"__{pluralVariable}.ToString()");
                    break;

                case IcuPluralNode:
                    break;
            }
        }
        return parts;
    }

    internal static string EscapeString(string value)
    {
        return value
            .Replace("\\", "\\\\")
            .Replace("\"", "\\\"")
            .Replace("\n", "\\n")
            .Replace("\r", "\\r")
            .Replace("\t", "\\t");
    }
}
